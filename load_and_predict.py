import keras.backend as K
import numpy as np
import h5py
import cv2
import os

from numpy import argmax
from keras.models import load_model
from sklearn.metrics import roc_curve

def dice_coef(y_true, y_pred, smooth = 1.0):
    """Compute Dice Similarity Coefficient (DSC)
        
        Parameters
        ----------
        y_true : 1D numpy array of float32
        Array of correct/ground truth labels
        y_pred : 1D numpy array of predictions
        Array of predicted labels generated by CNN
        smooth : float
        Defaults to 1.0
        
        Returns
        -------
        Returns the DSC
        
        Additional Notes
        -------
        Original source code can be found `here <https://github.com/jocicmarko/ultrasound-nerve-segmentation/blob/master/train.py>`_
        """
    flat_truth = K.flatten(y_true)
    flat_prediction = K.flatten(y_pred)
    intersection = K.sum(flat_truth * flat_prediction)
    numerator = 2 * intersection + smooth
    sum_truth = K.sum(flat_truth)
    sum_prediction = K.sum(flat_prediction)
    denominator = sum_truth + sum_prediction + smooth
    dice = numerator / denominator
    return dice

def dice_coef_loss(y_true, y_pred):
    """Dice Similarity Coefficient (DSC) loss function
    
    Parameters
    ----------
    y_true : 1D numpy array of float32
    Array of correct/ground truth labels
    y_pred : 1D numpy array of predictions
    Array of predicted labels generated by FCN
    
    Returns
    -------
    Returns the DSC loss
    
    """
    return -dice_coef(y_true, y_pred)

def best_thresh(y_true, y_score):
    """
    
    """

    # calculate roc curves
    fpr, tpr, thresholds = roc_curve(y_true.flatten(), y_score.flatten())

    gmeans = np.sqrt(tpr * (1-fpr))
    ix = argmax(gmeans)
    best_thresh = thresholds[ix]

    print('Best Threshold=%f, G-Mean=%.3f' % (best_thresh, gmeans[ix]))

    # # Youden's J statistic
    # J = tpr - fpr
    # ix = argmax(J)
    # best_thresh = thresholds[ix]
    # print('Best Threshold=%f' % (best_thresh))

    return best_thresh

def binary_masks(groundtruth, predictions):
    """
    
    """

    assert groundtruth.shape[0:3] == predictions.shape[0:3], "Groundtruth and prediction shapes don't match"

    binary_masks = []

    for i in range(groundtruth.shape[0]):
        label = groundtruth[i, :, :].astype(int)

        if not np.any(label): 
            binary_masks.append(label)
            continue

        out_mask = predictions[i, :, :]

        thresh = best_thresh(label, out_mask)

        ret, mask = cv2.threshold(out_mask, thresh, 1, cv2.THRESH_BINARY)
        binary_masks.append(mask)

    return np.array(binary_masks)

def load_and_predict(FCNModelPath, testingHDF5, predFileName):
    """Load FCN model and predict on a dataset
    
    Parameters
    ----------
    FCNModelPath : string - filepath to saved FCN model
    testingHDF5 : string - filepath to dataset
    predFileName: string - HDf5 file to which predictions will be saved
    
    Returns
    -------
    Returns nothing but saves predictions as HDF5 file
    """

    loaded_model = load_model(FCNModelPath, custom_objects={"dice_coef": dice_coef,"dice_coef_loss": dice_coef_loss})

    with h5py.File(testingHDF5, "r") as f:
        X_test = f["raw"][()]
        test_image_fileanmes = f["raw_names"][()]

    predictions = loaded_model.predict(X_test, verbose=1)
    predictions = np.array(predictions)
    
    # Binarize the predictions
    binary_images = []

    for i in range(predictions.shape[0]):
        image = predictions[i, :, :]
        ret, thresh = cv2.threshold(image, .5, 1, cv2.THRESH_BINARY)
        binary_images.append(thresh)

    print("Shape of predictions: " + str(predictions.shape))

    if os.path.exists(predFileName):
        os.remove(predFileName)

    hd5f_file = h5py.File(predFileName, mode="w")
    hd5f_file.create_dataset("predictions", data=predictions)
    hd5f_file.create_dataset("binary_predictions", data=binary_images)
    hd5f_file.create_dataset("file_names", data=test_image_fileanmes)
    hd5f_file.close()

    print(f"Saved predictions to {predFileName}")